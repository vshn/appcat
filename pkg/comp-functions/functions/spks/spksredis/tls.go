package spksredis

import (
	"context"
	"encoding/json"
	"fmt"

	xfnproto "github.com/crossplane/function-sdk-go/proto/v1"
	xhelm "github.com/vshn/appcat/v4/apis/helm/release/v1beta1"
	spksv1alpha1 "github.com/vshn/appcat/v4/apis/syntools/v1alpha1"
	"github.com/vshn/appcat/v4/pkg/comp-functions/functions/common"
	"github.com/vshn/appcat/v4/pkg/comp-functions/runtime"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
)

// HandleTLS will enable TLS if it's specified in the composite.
// It will then deploy certmanager objects to generate certificates.
func HandleTLS(ctx context.Context, comp *spksv1alpha1.CompositeRedisInstance, svc *runtime.ServiceRuntime) *xfnproto.Result {

	err := svc.GetObservedComposite(comp)
	if err != nil {
		return runtime.NewFatalResult(fmt.Errorf("cannot get composite for spks redis: %w", err))
	}

	err = scaleRedisRelease(svc, comp)
	if err != nil {
		return runtime.NewWarningResult("cannot scale redis release: " + err.Error())
	}

	if !comp.Spec.Parameters.TLS {
		return runtime.NewNormalResult("TLS not enabled")
	}

	cd, err := svc.GetObservedComposedResourceConnectionDetails("haproxy-chart")
	if err != nil {
		return runtime.NewWarningResult(fmt.Sprintf("cannot get connection details of haproxy: %s", err.Error()))
	}

	tlsOpts := &common.TLSOptions{
		AdditionalSans: []string{
			string(cd["endpoint"]),
			// These were determined by running the charts with autogenerated certs
			"127.0.0.1",
			"localhost",
			"redis",
			fmt.Sprintf("*.redis.%s.svc.cluster.local", comp.GetName()),
			fmt.Sprintf("redis-master.%s.svc.cluster.local", comp.GetName()),
			fmt.Sprintf("*.redis-master.%s.svc.cluster.local", comp.GetName()),
			fmt.Sprintf("*.redis-headless.%s.svc.cluster.local", comp.GetName()),
			fmt.Sprintf("redis-headless.%s.svc.cluster.local", comp.GetName()),
		},
		KubeOptions: []runtime.KubeObjectOption{
			runtime.KubeOptionAddLabels(map[string]string{
				runtime.IgnoreConnectionDetailsAnnotation: "true",
			}),
		},
	}

	_, err = common.CreateTLSCerts(ctx, comp.GetName(), comp.GetName(), svc, tlsOpts)
	if err != nil {
		return runtime.NewWarningResult(fmt.Sprintf("cannot apply certificates: %s", err.Error()))
	}

	return nil
}

func scaleRedisRelease(svc *runtime.ServiceRuntime, comp *spksv1alpha1.CompositeRedisInstance) error {
	obsRelease := &xhelm.Release{}

	err := svc.GetObservedComposedResource(obsRelease, "redis-chart")
	if err != nil {
		return fmt.Errorf("cannot get observed redis release: %w", err)
	}

	desRelease := &xhelm.Release{}

	err = svc.GetDesiredComposedResourceByName(desRelease, "redis-chart")
	if err != nil {
		return fmt.Errorf("cannot get desired redis release: %w", err)
	}

	if getRedisReleaseTLSStatus(obsRelease, svc) != getRedisReleaseTLSStatus(desRelease, svc) {
		values, err := convertValuesToMap(desRelease.Spec.ForProvider.Values.Raw)
		if err != nil {
			return err
		}

		err = common.SetNestedObjectValue(values, []string{"replica", "replicaCount"}, 0)
		if err != nil {
			return err
		}

		rawValues, err := json.Marshal(values)
		if err != nil {
			return err
		}

		desRelease.Spec.ForProvider.Values.Raw = rawValues

	}

	err = svc.SetDesiredComposedResourceWithName(desRelease, "redis-chart")
	if err != nil {
		return err
	}

	return nil
}

func getRedisReleaseTLSStatus(release *xhelm.Release, svc *runtime.ServiceRuntime) bool {

	rawValues := release.Spec.ForProvider.Values

	values, err := convertValuesToMap(rawValues.Raw)
	if err != nil {
		svc.Log.Info("cannot marshal release tls status: " + err.Error())
		return false
	}

	enabled, _, err := unstructured.NestedBool(values, "tls", "enabled")
	if err != nil {
		svc.Log.Info("cannot get tls status from values: " + err.Error())
		return false
	}

	return enabled
}

func convertValuesToMap(rawValues []byte) (map[string]any, error) {
	values := map[string]any{}
	err := json.Unmarshal(rawValues, &values)
	if err != nil {
		return nil, err
	}

	return values, nil
}
