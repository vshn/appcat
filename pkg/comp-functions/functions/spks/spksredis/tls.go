package spksredis

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	xfnproto "github.com/crossplane/function-sdk-go/proto/v1"
	xhelm "github.com/vshn/appcat/v4/apis/helm/release/v1beta1"
	spksv1alpha1 "github.com/vshn/appcat/v4/apis/syntools/v1alpha1"
	"github.com/vshn/appcat/v4/pkg/comp-functions/functions/common"
	"github.com/vshn/appcat/v4/pkg/comp-functions/runtime"
	appsv1 "k8s.io/api/apps/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
)

// HandleTLS will enable TLS if it's specified in the composite.
// It will then deploy certmanager objects to generate certificates.
func HandleTLS(ctx context.Context, comp *spksv1alpha1.CompositeRedisInstance, svc *runtime.ServiceRuntime) *xfnproto.Result {

	err := svc.GetObservedComposite(comp)
	if err != nil {
		return runtime.NewFatalResult(fmt.Errorf("cannot get composite for spks redis: %w", err))
	}

	err = scaleRedisRelease(svc, comp)
	if err != nil {
		return runtime.NewWarningResult("cannot scale redis release: " + err.Error())
	}

	if !comp.Spec.Parameters.TLS {
		svc.SetConnectionDetail("ca.crt", []byte("N/A"))
		return runtime.NewNormalResult("TLS not enabled")
	}

	cd, err := svc.GetObservedComposedResourceConnectionDetails("haproxy-chart")
	if err != nil {
		return runtime.NewWarningResult(fmt.Sprintf("cannot get connection details of haproxy: %s", err.Error()))
	}

	tlsOpts := &common.TLSOptions{
		AdditionalSans: []string{
			string(cd["endpoint"]),
			// These were determined by running the charts with autogenerated certs
			"127.0.0.1",
			"localhost",
			"redis",
			fmt.Sprintf("*.redis.%s.svc.cluster.local", comp.GetName()),
			fmt.Sprintf("redis-master.%s.svc.cluster.local", comp.GetName()),
			fmt.Sprintf("*.redis-master.%s.svc.cluster.local", comp.GetName()),
			fmt.Sprintf("*.redis-headless.%s.svc.cluster.local", comp.GetName()),
			fmt.Sprintf("redis-headless.%s.svc.cluster.local", comp.GetName()),
		},
		KubeOptions: []runtime.KubeObjectOption{
			runtime.KubeOptionAddLabels(map[string]string{
				runtime.IgnoreConnectionDetailsAnnotation: "true",
			}),
		},
	}

	_, err = common.CreateTLSCerts(ctx, comp.GetName(), comp.GetName(), svc, tlsOpts)
	if err != nil {
		return runtime.NewWarningResult(fmt.Sprintf("cannot apply certificates: %s", err.Error()))
	}

	svc.AddObservedConnectionDetails(comp.GetName() + "-server-cert")

	if !isCertAvailable(svc, comp) {
		err := updateReconcileTimestamp(svc, comp)
		if err != nil {
			return runtime.NewWarningResult(fmt.Sprintf("cannot update reconcile timestamp: %s", err.Error()))
		}
		svc.SetDesiredResourceReadiness(comp.GetName()+"-server-cert", runtime.ResourceUnReady)
	}

	return nil
}

func scaleRedisRelease(svc *runtime.ServiceRuntime, comp *spksv1alpha1.CompositeRedisInstance) error {
	obsRelease := &xhelm.Release{}

	err := svc.GetObservedComposedResource(obsRelease, "redis-chart")
	if err != nil {
		return fmt.Errorf("cannot get observed redis release: %w", err)
	}

	desRelease := &xhelm.Release{}

	err = svc.GetDesiredComposedResourceByName(desRelease, "redis-chart")
	if err != nil {
		return fmt.Errorf("cannot get desired redis release: %w", err)
	}

	if getRedisReleaseTLSStatus(obsRelease, svc) != getRedisReleaseTLSStatus(desRelease, svc) || isSTSScaling(obsRelease, comp, svc) {
		err := addSTSObserver(comp, svc)
		if err != nil {
			return err
		}

		values, err := convertValuesToMap(desRelease.Spec.ForProvider.Values.Raw)
		if err != nil {
			return err
		}

		err = common.SetNestedObjectValue(values, []string{"replica", "replicaCount"}, 0)
		if err != nil {
			return err
		}

		rawValues, err := json.Marshal(values)
		if err != nil {
			return err
		}

		desRelease.Spec.ForProvider.Values.Raw = rawValues

		err = updateReconcileTimestamp(svc, comp)
		if err != nil {
			return fmt.Errorf("cannot update composite status: %w", err)
		}

	}

	err = svc.SetDesiredComposedResourceWithName(desRelease, "redis-chart")
	if err != nil {
		return err
	}

	return nil
}

func getRedisReleaseTLSStatus(release *xhelm.Release, svc *runtime.ServiceRuntime) bool {

	rawValues := release.Spec.ForProvider.Values

	values, err := convertValuesToMap(rawValues.Raw)
	if err != nil {
		svc.Log.Info("cannot marshal release tls status: " + err.Error())
		return false
	}

	enabled, _, err := unstructured.NestedBool(values, "tls", "enabled")
	if err != nil {
		svc.Log.Info("cannot get tls status from values: " + err.Error())
		return false
	}

	return enabled
}

func convertValuesToMap(rawValues []byte) (map[string]any, error) {
	values := map[string]any{}
	err := json.Unmarshal(rawValues, &values)
	if err != nil {
		return nil, err
	}

	return values, nil
}

func addSTSObserver(comp *spksv1alpha1.CompositeRedisInstance, svc *runtime.ServiceRuntime) error {
	sts := &appsv1.StatefulSet{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "redis-node",
			Namespace: comp.GetName(),
		},
	}

	err := svc.SetDesiredKubeObject(sts, comp.GetName()+"-sts-observer", runtime.KubeOptionObserve)
	if err != nil {
		return err
	}

	return nil
}

// isSTSScaling will return true, if the release is set to 0 replicas and
// the sts hasn't fully scaled down yet.
// This is necessary to ensure that we don't have mixed tls/non-tls members in the cluster
// at the same time.
func isSTSScaling(obsRelease *xhelm.Release, comp *spksv1alpha1.CompositeRedisInstance, svc *runtime.ServiceRuntime) bool {
	sts := &appsv1.StatefulSet{}

	err := svc.GetObservedKubeObject(sts, comp.GetName()+"-sts-observer")
	if err != nil {
		svc.Log.Error(err, "cannot get sts observer")
		return false
	}

	obsValues, err := convertValuesToMap(obsRelease.Spec.ForProvider.Values.Raw)
	if err != nil {
		svc.Log.Error(err, "cannot convert values to map")
		return false
	}

	count, _, err := unstructured.NestedFloat64(obsValues, "replica", "replicaCount")
	if err != nil {
		svc.Log.Error(err, "cannot get replica.replicaCount")
		return false
	}

	if count == 0 {
		return !(sts.Status.Replicas == 0)
	}

	return false
}

func isCertAvailable(svc *runtime.ServiceRuntime, comp *spksv1alpha1.CompositeRedisInstance) bool {
	// Safety measure, if the instance is older than 10 minutes we don't do this check anymore.
	now := time.Now()
	creation := comp.GetCreationTimestamp()
	diff := now.Sub(creation.Time)
	if diff.Minutes() >= 10 {
		return true
	}

	cd := svc.GetConnectionDetails()

	cert := string(cd["ca.crt"])

	if cert == "" {
		return false
	}

	return true
}

// updateReconcileTimestamp will update a field in the status called `reconcileTimeStamp`.
// This will instantly trigger a new reconcile.
// Making the switch from TLS to non-TLS much faster on SPK. Because SPKS has a
// default reconcile period of 10 minutes.
func updateReconcileTimestamp(svc *runtime.ServiceRuntime, comp *spksv1alpha1.CompositeRedisInstance) error {
	comp.Status.ReconcileTimeStamp = time.Now().Format(time.RFC3339Nano)
	time.Sleep(time.Millisecond * 500)
	return svc.SetDesiredCompositeStatus(comp)
}
