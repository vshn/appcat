package spksredis

import (
	"context"
	"fmt"
	"time"

	v1 "github.com/cert-manager/cert-manager/pkg/apis/certmanager/v1"
	xfnproto "github.com/crossplane/function-sdk-go/proto/v1"
	spksv1alpha1 "github.com/vshn/appcat/v4/apis/syntools/v1alpha1"
	"github.com/vshn/appcat/v4/pkg/comp-functions/functions/common"
	"github.com/vshn/appcat/v4/pkg/comp-functions/runtime"
)

// HandleTLS will enable TLS if it's specified in the composite.
// It will then deploy certmanager objects to generate certificates.
func HandleTLS(ctx context.Context, comp *spksv1alpha1.CompositeRedisInstance, svc *runtime.ServiceRuntime) *xfnproto.Result {

	err := svc.GetObservedComposite(comp)
	if err != nil {
		return runtime.NewFatalResult(fmt.Errorf("cannot get composite for spks redis: %w", err))
	}

	if !comp.Spec.Parameters.TLS {
		svc.SetConnectionDetail("ca.crt", []byte("N/A"))
		return runtime.NewNormalResult("TLS not enabled")
	}

	cd, err := svc.GetObservedComposedResourceConnectionDetails("redis-chart")
	if err != nil {
		return runtime.NewWarningResult(fmt.Sprintf("cannot get connection details of haproxy: %s", err.Error()))
	}

	tlsOpts := &common.TLSOptions{
		AdditionalSans: []string{
			string(cd["endpoint"]),
			// These were determined by running the charts with autogenerated certs
			"127.0.0.1",
			"localhost",
			"redis",
			fmt.Sprintf("*.redis.%s.svc.cluster.local", comp.GetName()),
			fmt.Sprintf("redis-announce-0.%s.svc.cluster.local", comp.GetName()),
			fmt.Sprintf("redis-announce-1.%s.svc.cluster.local", comp.GetName()),
			fmt.Sprintf("redis-announce-2	.%s.svc.cluster.local", comp.GetName()),
			fmt.Sprintf("redis.%s.svc.cluster.local", comp.GetName()),
		},
		AdditionalOutputFormats: []v1.CertificateAdditionalOutputFormat{
			{
				Type: v1.CertificateOutputFormatCombinedPEM,
			},
		},
		KubeOptions: []runtime.KubeObjectOption{
			runtime.KubeOptionAddLabels(map[string]string{
				runtime.IgnoreConnectionDetailsAnnotation: "true",
			}),
		},
	}

	_, err = common.CreateTLSCerts(ctx, comp.GetName(), comp.GetName(), svc, tlsOpts)
	if err != nil {
		return runtime.NewWarningResult(fmt.Sprintf("cannot apply certificates: %s", err.Error()))
	}

	svc.AddObservedConnectionDetails(comp.GetName() + "-server-cert")

	if !isCertAvailable(svc, comp) {
		err := updateReconcileTimestamp(svc, comp)
		if err != nil {
			return runtime.NewWarningResult(fmt.Sprintf("cannot update reconcile timestamp: %s", err.Error()))
		}
		svc.SetDesiredResourceReadiness(comp.GetName()+"-server-cert", runtime.ResourceUnReady)
	}

	return nil
}

func isCertAvailable(svc *runtime.ServiceRuntime, comp *spksv1alpha1.CompositeRedisInstance) bool {
	// Safety measure, if the instance is older than 10 minutes we don't do this check anymore.
	now := time.Now()
	creation := comp.GetCreationTimestamp()
	diff := now.Sub(creation.Time)
	if diff.Minutes() >= 10 {
		return true
	}

	cd := svc.GetConnectionDetails()

	cert := string(cd["ca.crt"])

	return cert != ""
}

// updateReconcileTimestamp will update a field in the status called `reconcileTimeStamp`.
// This will instantly trigger a new reconcile.
// Making the switch from TLS to non-TLS much faster on SPK. Because SPKS has a
// default reconcile period of 10 minutes.
func updateReconcileTimestamp(svc *runtime.ServiceRuntime, comp *spksv1alpha1.CompositeRedisInstance) error {
	comp.Status.ReconcileTimeStamp = time.Now().Format(time.RFC3339Nano)
	time.Sleep(time.Millisecond * 500)
	return svc.SetDesiredCompositeStatus(comp)
}
