pg_replication:
  master: true
  query:
    "SELECT\nCASE\n  WHEN pg_last_wal_receive_lsn() = pg_last_wal_replay_lsn()\
    \ THEN 0\n  ELSE extract (EPOCH FROM now() - pg_last_xact_replay_timestamp())::integer\n\
    END AS lag,\nCASE\n  WHEN pg_is_in_recovery() THEN 1\n  ELSE 0\nEND AS is_replicating;\n"
  metrics:
    - lag:
        usage: "GAUGE"
        description: "Replication lag behind master in seconds"
    - is_replicating:
        usage: "GAUGE"
        description: "Indicates if this host is a replica"
pg_postmaster:
  master: true
  query: "SELECT pg_postmaster_start_time as start_time_seconds from pg_postmaster_start_time()"
  metrics:
    - start_time_seconds:
        usage: "GAUGE"
        description: "Time at which postmaster started"
pg_blocked:
  master: true
  query:
    "SET max_parallel_workers_per_gather = 0;\nWITH databases AS (\n  SELECT\
    \ oid, datname FROM pg_database\n  WHERE datname NOT IN ('template0', 'template1')\n\
    )\nSELECT\n  locktype AS type,\n  NULL AS datname,\n  NULL AS schemaname,\n  NULL\
    \ AS reltype,\n  NULL AS relname,\n  count(*) AS queries\nFROM pg_catalog.pg_locks\
    \ blocked\nWHERE NOT blocked.granted AND relation IS NULL\nGROUP BY locktype\n\
    UNION\nSELECT\n  locktype AS type,\n  datname,\n  schemaname,\n  CASE relkind\n\
    \    WHEN 'r' THEN 'ordinary table'\n    WHEN 'i' THEN 'index'\n    WHEN 'S' THEN\
    \ 'sequence'\n    WHEN 't' THEN 'TOAST table'\n    WHEN 'v' THEN 'view'\n    WHEN\
    \ 'm' THEN 'materialized view'\n    WHEN 'c' THEN 'composite type'\n    WHEN 'f'\
    \ THEN 'foreign table'\n    WHEN 'p' THEN 'partitioned table'\n    WHEN 'I' THEN\
    \ 'partitioned index'\n    ELSE 'unknown type ''' || relkind || ''''\n    END\
    \ AS reltype,\n  relname,\n  count(*) AS queries\nFROM pg_catalog.pg_locks blocked\n\
    INNER JOIN databases\n  ON blocked.database = databases.oid,\n  LATERAL (SELECT\
    \ * FROM dblink(\n    'host=/var/run/postgresql port=5432 user=' || CURRENT_USER\
    \ || ' sslmode=disable dbname=''' || regexp_replace(datname, '([.\\\\])', '\\\\\
    \\1', 'g') || '''',\n    'SELECT nspname as schemaname, relkind, relname FROM\
    \ pg_catalog.pg_class LEFT JOIN pg_catalog.pg_namespace ON (pg_namespace.oid =\
    \ relnamespace) WHERE pg_class.oid = ' || blocked.relation)\n    AS (schemaname\
    \ name, relkind char, relname name)) AS _\nWHERE NOT blocked.granted AND relation\
    \ IS NOT NULL\nGROUP BY locktype, datname, schemaname, reltype, relname;\n"
  metrics:
    - type:
        usage: "LABEL"
        description: "The lock type"
    - datname:
        usage: "LABEL"
        description: "Database name"
    - schemaname:
        usage: "LABEL"
        description: "The schema on which a query is blocked"
    - reltype:
        usage: "LABEL"
        description: "The type of relation"
    - relname:
        usage: "LABEL"
        description: "The relation on which a query is blocked"
    - queries:
        usage: "GAUGE"
        description: "The current number of blocked queries"
pg_oldest_blocked:
  master: true
  query:
    "SELECT datname,\n  coalesce(extract('epoch' from max(clock_timestamp() -\
    \ state_change)), 0) age_seconds\nFROM pg_catalog.pg_stat_activity\nWHERE wait_event_type\
    \ = 'Lock'\nAND state='active'\nGROUP BY datname;\n"
  metrics:
    - age_seconds:
        usage: "GAUGE"
        description:
          "Largest number of seconds any transaction is currently waiting\
          \ on a lock"
    - datname:
        usage: "LABEL"
        description: "Database name"
pg_slow:
  master: true
  query:
    "SELECT datname, COUNT(*) AS queries\nFROM pg_catalog.pg_stat_activity\n\
    WHERE state = 'active' AND (now() - query_start) > '1 seconds'::interval\nGROUP\
    \ BY datname;\n"
  metrics:
    - queries:
        usage: "GAUGE"
        description: "Current number of slow queries"
    - datname:
        usage: "LABEL"
        description: "Database name"
pg_long_running_transactions:
  master: true
  query:
    "SELECT datname, COUNT(*) as count,\nMAX(EXTRACT(EPOCH FROM (clock_timestamp()\
    \ - xact_start))) AS age_in_seconds\nFROM pg_catalog.pg_stat_activity\nWHERE state\
    \ is distinct from 'idle' AND (now() - xact_start) > '1 minutes'::interval AND\
    \ query not like '%VACUUM%'\nGROUP BY datname;\n"
  metrics:
    - datname:
        usage: "LABEL"
        description: "Database name"
    - count:
        usage: "GAUGE"
        description: "Current number of long running transactions"
    - age_in_seconds:
        usage: "GAUGE"
        description: "The current maximum transaction age in seconds"
pg_vacuum:
  master: true
  query:
    "SELECT\n  datname,\n  COUNT(*) AS queries,\n  MAX(EXTRACT(EPOCH FROM (clock_timestamp()\
    \ - query_start))) AS age_in_seconds\nFROM pg_catalog.pg_stat_activity\nWHERE\
    \ state = 'active' AND trim(query) ~* '\\AVACUUM (?!ANALYZE)'\nGROUP BY datname;\n"
  metrics:
    - datname:
        usage: "LABEL"
        description: "Database name"
    - queries:
        usage: "GAUGE"
        description: "The current number of VACUUM queries"
    - age_in_seconds:
        usage: "GAUGE"
        description: "The current maximum VACUUM query age in seconds"
pg_vacuum_analyze:
  master: true
  query:
    "SELECT\n  datname,\n  COUNT(*) AS queries,\n  MAX(EXTRACT(EPOCH FROM (clock_timestamp()\
    \ - query_start))) AS age_in_seconds\nFROM pg_catalog.pg_stat_activity\nWHERE\
    \ state = 'active' AND trim(query) ~* '\\AVACUUM ANALYZE'\nGROUP BY datname;\n"
  metrics:
    - datname:
        usage: "LABEL"
        description: "Database name"
    - queries:
        usage: "GAUGE"
        description: "The current number of VACUUM ANALYZE queries"
    - age_in_seconds:
        usage: "GAUGE"
        description: "The current maximum VACUUM ANALYZE query age in seconds"
pg_stuck_idle_in_transaction:
  master: true
  query:
    "SELECT datname,\n  COUNT(*) AS queries\nFROM pg_catalog.pg_stat_activity\n\
    WHERE state = 'idle in transaction' AND (now() - query_start) > '10 minutes'::interval\n\
    GROUP BY datname;\n"
  metrics:
    - datname:
        usage: "LABEL"
        description: "Database name"
    - queries:
        usage: "GAUGE"
        description: "Current number of queries that are stuck being idle in transactions"
pg_txid:
  master: true
  query:
    "SELECT\n  CASE WHEN pg_is_in_recovery() THEN 'NaN'::float ELSE txid_current()\
    \ % (2^52)::bigint END AS current,\n  CASE WHEN pg_is_in_recovery() THEN 'NaN'::float\
    \ ELSE txid_snapshot_xmin(txid_current_snapshot()) % (2^52)::bigint END AS xmin,\n\
    \  CASE WHEN pg_is_in_recovery() THEN 'NaN'::float ELSE txid_current() - txid_snapshot_xmin(txid_current_snapshot())\
    \ END AS xmin_age;\n"
  metrics:
    - current:
        usage: "COUNTER"
        description:
          "Current 64-bit transaction id of the query used to collect this\
          \ metric (truncated to low 52 bits)"
    - xmin:
        usage: "COUNTER"
        description:
          "Oldest transaction id of a transaction still in progress, i.e.\
          \ not known committed or aborted (truncated to low 52 bits)"
    - xmin_age:
        usage: "GAUGE"
        description:
          "Age of oldest transaction still not committed or aborted measured\
          \ in transaction ids"
pg_database_datfrozenxid:
  master: true
  query: "SELECT datname, age(datfrozenxid) AS age FROM pg_catalog.pg_database;\n"
  metrics:
    - datname:
        usage: "LABEL"
        description: "Database Name"
    - age:
        usage: "GAUGE"
        description: "Age of the oldest transaction that has not been frozen."
pg_wal_position:
  master: true
  query:
    "SELECT CASE\n       WHEN pg_is_in_recovery()\n       THEN (pg_last_wal_receive_lsn()\
    \ - '0/0') % (2^52)::bigint\n       ELSE (pg_current_wal_lsn() - '0/0') % (2^52)::bigint\n\
    \       END AS bytes;\n"
  metrics:
    - bytes:
        usage: "COUNTER"
        description:
          "Postgres LSN (log sequence number) being generated on primary\
          \ or replayed on replica (truncated to low 52 bits)"
pg_replication_slots_stats:
  master: true
  query:
    "SELECT slot_name, slot_type,\n       case when active then 1.0 else 0.0\
    \ end AS active,\n       age(xmin) AS xmin_age,\n       age(catalog_xmin) AS catalog_xmin_age,\n\
    \       CASE WHEN pg_is_in_recovery() THEN pg_last_wal_receive_lsn() ELSE pg_current_wal_lsn()\
    \ END - restart_lsn AS restart_lsn_bytes,\n       CASE WHEN pg_is_in_recovery()\
    \ THEN pg_last_wal_receive_lsn() ELSE pg_current_wal_lsn() END - confirmed_flush_lsn\
    \ AS confirmed_flush_lsn_bytes\n  FROM pg_catalog.pg_replication_slots;\n"
  metrics:
    - slot_name:
        usage: "LABEL"
        description: "Slot Name"
    - slot_type:
        usage: "LABEL"
        description: "Slot Type"
    - active:
        usage: "GAUGE"
        description:
          "Boolean flag indicating whether this slot has a consumer streaming\
          \ from it"
    - xmin_age:
        usage: "GAUGE"
        description:
          "Age of oldest transaction that cannot be vacuumed due to this\
          \ replica"
    - catalog_xmin_age:
        usage: "GAUGE"
        description:
          "Age of oldest transaction that cannot be vacuumed from catalogs\
          \ due to this replica (used by logical replication)"
    - restart_lsn_bytes:
        usage: "GAUGE"
        description:
          "Amount of data on in xlog that must be this replica may need to\
          \ complete recovery"
    - confirmed_flush_lsn_bytes:
        usage: "GAUGE"
        description:
          "Amount of data on in xlog that must be this replica has not yet\
          \ received"
pg_replication_status:
  master: true
  query:
    "SELECT\n  application_name,\n  client_addr,\n  state,\n  pg_wal_lsn_diff(pg_stat_replication.sent_lsn,\
    \ pg_stat_replication.replay_lsn) AS lag_size\nFROM pg_stat_replication;\n"
  metrics:
    - application_name:
        usage: "LABEL"
        description: "Application or node name"
    - client_addr:
        usage: "LABEL"
        description: "Client ip address"
    - state:
        usage: "LABEL"
        description: "Client replication state"
    - lag_size_bytes:
        usage: "GAUGE"
        description: "Replication lag size in bytes"
pg_vaccuum_wraparound:
  master: true
  query:
    "SET max_parallel_workers_per_gather = 0;\nWITH databases AS (\nSELECT datname\
    \ FROM pg_database\nWHERE datname NOT IN ('template0', 'template1')\n)\nSELECT\
    \ datname, _.* FROM databases, (SELECT true WHERE NOT pg_is_in_recovery()) AS\
    \ pg_is_not_in_recovery,\nLATERAL (SELECT * FROM dblink(\n    'host=/var/run/postgresql\
    \ port=5432 user=' || CURRENT_USER || ' sslmode=disable dbname=''' || regexp_replace(datname,\
    \ '([.\\\\])', '\\\\\\1', 'g') || '''',\n    '\n    WITH tabfreeze AS (\n    \
    \    SELECT pg_class.oid::regclass AS full_table_name,\n        greatest(age(pg_class.relfrozenxid),\
    \ age(toast.relfrozenxid)) as freeze_age,\n        pg_total_relation_size(pg_class.oid),\n\
    \        case\n                when array_to_string(pg_class.reloptions, '''')\
    \ like ''%autovacuum_freeze_max_age%'' then regexp_replace(array_to_string(pg_class.reloptions,\
    \ ''''), ''.*autovacuum_freeze_max_age=([0-9.]+).*'', E''\\\\1'')::int8\n    \
    \            else current_setting(''autovacuum_freeze_max_age'')::int8\n     \
    \       end as autovacuum_freeze_max_age\n    FROM pg_class JOIN pg_namespace\
    \ ON pg_class.relnamespace = pg_namespace.oid\n        LEFT OUTER JOIN pg_class\
    \ as toast\n            ON pg_class.reltoastrelid = toast.oid\n    WHERE nspname\
    \ not in (''pg_catalog'', ''information_schema'')\n        AND nspname NOT LIKE\
    \ ''pg_temp%''\n        AND pg_class.relkind = ''r''\n    )\n    SELECT full_table_name,\
    \  pg_total_relation_size,freeze_age,autovacuum_freeze_max_age, (freeze_age*1)::bigint/(autovacuum_freeze_max_age/100)\
    \ as \"percent\"\n    FROM tabfreeze\n    WHERE pg_total_relation_size >=  10000000000\
    \ -- size of table 10 GB\n    AND (freeze_age*1)::bigint/(autovacuum_freeze_max_age/100)>=90\
    \ --percent of txid\n    ORDER BY 5 DESC;\n\n    ')\n    AS (full_table_name name,\
    \ table_size bigint, freeze_age bigint, autovacuum_freeze_max_age bigint, percent\
    \ integer)) AS _;\n"
  metrics:
    - datname:
        usage: "LABEL"
        description: "Database name"
    - full_table_name:
        usage: "LABEL"
        description: "Full table name"
    - table_size:
        usage: "GAUGE"
        description: "Table size"
    - freeze_age:
        usage: "GAUGE"
        description: "Freeze age"
    - autovacuum_freeze_max_age:
        usage: "GAUGE"
        description: "Autovacuum freeze max age"
    - percent:
        usage: "GAUGE"
        description: "Percentage"
pg_stat_current_waiting_query:
  query:
    "SELECT\n    datname, wait_event, count(*) AS count\nFROM pg_stat_activity\n\
    WHERE state = 'active' AND wait_event IS NOT NULL\nGROUP BY datname, wait_event;\n"
  master: true
  metrics:
    - datname:
        usage: "LABEL"
        description: "Name of the database"
    - wait_event:
        usage: "LABEL"
        description: "Name of the wait event"
    - count:
        usage: "GAUGE"
        description: "# of queries waiting for other process to finish"
pg_stat_progress_vacuum:
  query:
    "SET max_parallel_workers_per_gather = 0;\nWITH databases AS (\nSELECT datname\
    \ FROM pg_database\nWHERE datname NOT IN ('template0', 'template1')\n)\nSELECT\
    \ DISTINCT ON (datname, schemaname, relname) _.* FROM databases,\nLATERAL (SELECT\
    \ * FROM dblink(\n    'host=/var/run/postgresql port=5432 user=' || CURRENT_USER\
    \ || ' sslmode=disable dbname=''' || regexp_replace(datname, '([.\\\\])', '\\\\\
    \\1', 'g') || '''',\n    '\n    SELECT\n      datname,\n      nspname AS schemaname,\n\
    \      relname,\n      heap_blks_total,\n      heap_blks_scanned,\n      heap_blks_vacuumed,\n\
    \      index_vacuum_count,'\n    || CASE WHEN (SELECT setting FROM pg_settings\
    \ WHERE name = 'server_version_num')::bigint >= 170000 THEN\n      '\n      NULL\
    \ AS max_dead_tuples,\n      NULL AS num_dead_tuples,\n      max_dead_tuple_bytes,\n\
    \      dead_tuple_bytes,\n      num_dead_item_ids,\n      indexes_total,\n   \
    \   indexes_processed\n      '\n      ELSE\n      '\n      max_dead_tuples,\n\
    \      num_dead_tuples,\n      NULL AS max_dead_tuple_bytes,\n      NULL AS dead_tuple_bytes,\n\
    \      NULL AS num_dead_item_ids,\n      NULL AS indexes_total,\n      NULL AS\
    \ indexes_processed\n      '\n      END\n    || '\n    FROM pg_stat_progress_vacuum\n\
    \    JOIN pg_class ON (pg_stat_progress_vacuum.relid = pg_class.oid)\n    JOIN\
    \ pg_namespace ON (pg_class.relnamespace = pg_namespace.oid)\n    ')\n    AS (datname\
    \ text,\n        schemaname text,\n        relname text,\n        heap_blks_total\
    \ bigint,\n        heap_blks_scanned bigint,\n        heap_blks_vacuumed bigint,\n\
    \        index_vacuum_count bigint,\n        max_dead_tuples bigint,\n       \
    \ num_dead_tuples bigint,\n        max_dead_tuple_bytes bigint,\n        dead_tuple_bytes\
    \ bigint,\n        num_dead_item_ids bigint,\n        indexes_total bigint,\n\
    \        indexes_processed bigint)) AS _;\n"
  master: true
  metrics:
    - datname:
        usage: "LABEL"
        description: "Name of the database to which this backend is connected"
    - schemaname:
        usage: "LABEL"
        description: "Name of the schema that this table is in"
    - relname:
        usage: "LABEL"
        description: "Name of this table"
    - heap_blks_total:
        usage: "GAUGE"
        description: "Total number of heap blocks in the table"
    - heap_blks_scanned:
        usage: "GAUGE"
        description: "Number of heap blocks scanned"
    - heap_blks_vacuumed:
        usage: "GAUGE"
        description: "Number of heap blocks vacuumed"
    - index_vacuum_count:
        usage: "GAUGE"
        description: "Number of completed index vacuum cycles"
    - max_dead_tuples:
        usage: "GAUGE"
        description:
          "Number of dead tuples that we can store before needing to perform\
          \ an index vacuum cycle"
    - num_dead_tuples:
        usage: "GAUGE"
        description: "Number of dead tuples collected since the last index vacuum cycle"
    - max_dead_tuple_bytes:
        usage: "GAUGE"
        description:
          "Amount of dead tuple data that we can store before needing to\
          \ perform an index vacuum cycle, based on maintenance_work_mem"
    - dead_tuple_bytes:
        usage: "GAUGE"
        description:
          "Amount of dead tuple data collected since the last index vacuum\
          \ cycle"
    - num_dead_item_ids:
        usage: "GAUGE"
        description:
          "Number of dead item identifiers collected since the last index\
          \ vacuum cycle"
    - indexes_total:
        usage: "GAUGE"
        description:
          "Total number of indexes that will be vacuumed or cleaned up. This\
          \ number is reported at the beginning of the vacuuming indexes phase or the\
          \ cleaning up indexes phase"
    - indexes_processed:
        usage: "GAUGE"
        description:
          "Number of indexes processed. This counter only advances when the\
          \ phase is vacuuming indexes or cleaning up indexes"
pg_stat_progress_cluster:
  query:
    "SET max_parallel_workers_per_gather = 0;\nWITH databases AS (\nSELECT datname\
    \ FROM pg_database\nWHERE datname NOT IN ('template0', 'template1')\n)\nSELECT\
    \ DISTINCT ON (datname, schemaname, relname) _.* FROM databases,\nLATERAL (SELECT\
    \ * FROM dblink(\n    'host=/var/run/postgresql port=5432 user=' || CURRENT_USER\
    \ || ' sslmode=disable dbname=''' || regexp_replace(datname, '([.\\\\])', '\\\\\
    \\1', 'g') || '''',\n    '\n    SELECT\n      datname,\n      nspname AS schemaname,\n\
    \      relname,\n      heap_tuples_scanned,\n      heap_tuples_written,\n    \
    \  heap_blks_total,\n      heap_blks_scanned,\n      index_rebuild_count\n   \
    \ FROM pg_stat_progress_cluster\n    JOIN pg_class ON (pg_stat_progress_cluster.relid\
    \ = pg_class.oid)\n    JOIN pg_namespace ON (pg_class.relnamespace = pg_namespace.oid)\n\
    \    ')\n    AS (datname text,\n        schemaname text,\n        relname text,\n\
    \        heap_tuples_scanned bigint,\n        heap_tuples_written bigint,\n  \
    \      heap_blks_total bigint,\n        heap_blks_scanned bigint,\n        index_rebuild_count\
    \ bigint)) AS _;\n"
  master: true
  metrics:
    - datname:
        usage: "LABEL"
        description: "Name of the database to which this backend is connected"
    - schemaname:
        usage: "LABEL"
        description: "Name of the schema that this table is in"
    - relname:
        usage: "LABEL"
        description: "Name of this table"
    - heap_tuples_scanned:
        usage: "GAUGE"
        description:
          "Number of heap tuples scanned. This counter only advances when\
          \ the phase is seq scanning heap, index scanning heap or writing new heap"
    - heap_tuples_written:
        usage: "GAUGE"
        description:
          "Number of heap tuples written. This counter only advances when\
          \ the phase is seq scanning heap, index scanning heap or writing new heap"
    - heap_blks_total:
        usage: "GAUGE"
        description:
          "Total number of heap blocks in the table. This number is reported\
          \ as of the beginning of seq scanning heap"
    - heap_blks_scanned:
        usage: "GAUGE"
        description:
          "Number of heap blocks scanned. This counter only advances when\
          \ the phase is seq scanning heap"
    - index_rebuild_count:
        usage: "GAUGE"
        description:
          "Number of indexes rebuilt. This counter only advances when the\
          \ phase is rebuilding index"
pgbouncer_show_clients:
  master: true
  query:
    "SELECT _.type,\n_.\"user\",\n_.database,\n_.replication,\n_.state,\n_.addr,\n\
    _.port,\n_.local_addr,\n_.local_port,\n_.connect_time,\n_.request_time,\n_.wait,\n\
    _.wait_us,\n_.close_needed,\n_.ptr,\n_.link,\n_.remote_pid,\n_.tls,\n_.application_name,\n\
    _.prepared_statements\nFROM dblink('host=/var/run/postgresql port=6432 dbname=pgbouncer\
    \ user=pgbouncer', 'show clients'::text)\nAS _(type text, \"user\" text, database\
    \ text, replication text, state text, addr text, port integer, local_addr text,\
    \ local_port integer,\nconnect_time timestamp with time zone, request_time timestamp\
    \ with time zone, wait integer, wait_us integer, close_needed integer,\nptr text,\
    \ link text, remote_pid integer, tls text, application_name text, prepared_statements\
    \ integer, uid bigint);\n"
  metrics:
    - type:
        usage: "LABEL"
        description: "C, for client."
    - user:
        usage: "LABEL"
        description: "Client connected user"
    - database:
        usage: "LABEL"
        description: "Database name"
    - replication:
        usage: "LABEL"
        description: "Replication status"
    - state:
        usage: "LABEL"
        description: "State of the client connection, one of active or waiting"
    - addr:
        usage: "LABEL"
        description: "IP address of client"
    - port:
        usage: "GAUGE"
        description: "Port client is connected to"
    - local_addr:
        usage: "LABEL"
        description: "Connection end address on local machine"
    - local_port:
        usage: "GAUGE"
        description: "Connection end port on local machine"
    - connect_time:
        usage: "LABEL"
        description: "Timestamp of connect time"
    - request_time:
        usage: "LABEL"
        description: "Timestamp of latest client request"
    - wait:
        usage: "GAUGE"
        description: "Current waiting time in seconds"
    - wait_us:
        usage: "GAUGE"
        description: "Microsecond part of the current waiting time"
    - close_needed:
        usage: "GAUGE"
        description: "not used for clients"
    - ptr:
        usage: "LABEL"
        description:
          "Address of internal object for this connection. Used as unique\
          \ ID"
    - link:
        usage: "LABEL"
        description: "Address of server connection the client is paired with"
    - remote_pid:
        usage: "GAUGE"
        description:
          "Process ID, in case client connects over Unix socket and OS supports\
          \ getting it"
    - tls:
        usage: "LABEL"
        description:
          "A string with TLS connection information, or empty if not using\
          \ TLS"
    - application_name:
        usage: "LABEL"
        description:
          "A string containing the application_name set by the client for\
          \ this connection, or empty if this was not set"
    - prepared_statements:
        usage: "GAUGE"
        description: "The amount of prepared statements that the client has prepared"
pgbouncer_show_pools:
  master: true
  query:
    "SELECT _.database,\n_.\"user\",\n_.cl_active,\n_.cl_waiting,\n_.cl_active_cancel_req,\n\
    _.cl_waiting_cancel_req,\n_.sv_active,\n_.sv_active_cancel,\n_.sv_being_canceled,\n\
    _.sv_idle,\n_.sv_used,\n_.sv_tested,\n_.sv_login,\n_.maxwait,\n_.maxwait_us,\n\
    _.pool_mode\nFROM dblink('host=/var/run/postgresql port=6432 dbname=pgbouncer\
    \ user=pgbouncer', 'show pools'::text)\n_(database text, \"user\" text, cl_active\
    \ integer, cl_waiting integer, cl_active_cancel_req integer, cl_waiting_cancel_req\
    \ integer,\nsv_active integer, sv_active_cancel integer, sv_being_canceled integer,\
    \ sv_idle integer, sv_used integer,\nsv_tested integer, sv_login integer, maxwait\
    \ integer, maxwait_us integer, pool_mode text, load_balance_hosts text);\n"
  metrics:
    - database:
        usage: "LABEL"
        description: "Database name"
    - replication:
        usage: "LABEL"
        description: "Replication type"
    - user:
        usage: "LABEL"
        description: "User name"
    - cl_active:
        usage: "GAUGE"
        description:
          "Client connections that are linked to server connection and can\
          \ process queries"
    - cl_waiting:
        usage: "GAUGE"
        description:
          "Client connections that have sent queries but have not yet got\
          \ a server connection"
    - cl_active_cancel_req:
        usage: "GAUGE"
        description:
          "Client connections that have forwarded query cancellations to\
          \ the server and are waiting for the server response"
    - cl_waiting_cancel_req:
        usage: "GAUGE"
        description:
          "    Client connections that have forwarded query cancellations\
          \ to the server and are waiting for the server response"
    - cl_waiting_cancel_req:
        usage: "GAUGE"
        description:
          "Client connections that have not forwarded query cancellations\
          \ to the server yet"
    - sv_active:
        usage: "GAUGE"
        description: "Server connections that are linked to a client"
    - sv_active_cancel:
        usage: "GAUGE"
        description: "Server connections that are currently forwarding a cancel request"
    - sv_being_canceled:
        usage: "GAUGE"
        description:
          "Servers that normally could become idle but are waiting to do\
          \ so until all in-flight cancel requests have completed that were sent to\
          \ cancel a query on this server"
    - sv_idle:
        usage: "GAUGE"
        description:
          "Server connections that are unused and immediately usable for\
          \ client queries"
    - sv_used:
        usage: "GAUGE"
        description:
          "Server connections that have been idle for more than server_check_delay\
          \ so they need server_check_query to run on them"
    - sv_tested:
        usage: "GAUGE"
        description:
          "Server connections that are currently running either server_reset_query\
          \ or server_check_query"
    - sv_login:
        usage: "GAUGE"
        description: "Server connections currently in the process of logging in"
    - maxwait:
        usage: "GAUGE"
        description: "How long the first oldest client in the queue has waited, in seconds"
    - maxwait_us:
        usage: "GAUGE"
        description: "Microsecond part of the maximum waiting time"
    - pool_mode:
        usage: "LABEL"
        description: "The pooling mode in use"
pgbouncer_show_databases:
  master: true
  query:
    "SELECT _.name,\n_.host,\n_.port,\n_.database,\n_.force_user,\n_.pool_size,\n\
    _.min_pool_size,\n_.reserve_pool,\n_.server_lifetime,\n_.pool_mode,\n_.max_connections,\n\
    _.current_connections,\n_.max_client_connections,\n_.current_client_connections,\n\
    _.paused,\n_.disabled\nFROM dblink('host=/var/run/postgresql port=6432 dbname=pgbouncer\
    \ user=pgbouncer', 'show databases'::text)\nAS _(name text, host text, port integer,\
    \ database text, force_user text, pool_size integer, min_pool_size integer,\n\
    \  reserve_pool integer, server_lifetime integer, pool_mode text, load_balance_hosts\
    \ text,\n  max_connections integer, current_connections integer, max_client_connections\
    \ integer, current_client_connections integer,\n  paused boolean, disabled boolean);\n"
  metrics:
    - name:
        usage: "LABEL"
        description: "Name of configured database entry"
    - host:
        usage: "LABEL"
        description: "Host pgbouncer connects to"
    - port:
        usage: "GAUGE"
        description: "Port pgbouncer connects to"
    - database:
        usage: "LABEL"
        description: "Actual database name pgbouncer connects to."
    - force_user:
        usage: "LABEL"
        description:
          "When the user is part of the connection string the connection\
          \ between pgbouncer and PostgreSQL is forced to the given user"
    - pool_size:
        usage: "GAUGE"
        description: "Maximum number of server connections"
    - min_pool_size:
        usage: "GAUGE"
        description: "Minimum number of server connections"
    - reserve_pool:
        usage: "GAUGE"
        description: "Maximum number of additional connections for this database"
    - server_lifetime:
        usage: "GAUGE"
        description: "The maximum lifetime of a server connection for this database"
    - pool_mode:
        usage: "LABEL"
        description: "The database override pool_mode"
    - max_connections:
        usage: "GAUGE"
        description:
          "    Maximum number of allowed server connections for this database,\
          \ as set by max_db_connections, either globally or per database"
    - current_connections:
        usage: "GAUGE"
        description: "Current number of connections for this database"
    - max_client_connections:
        usage: "GAUGE"
        description:
          "Maximum number of allowed client connections for this pgbouncer\
          \ instance, as set by max_db_client_connections per database"
    - current_client_connections:
        usage: "GAUGE"
        description: "    Current number of client connections for this database"
    - paused:
        usage: "GAUGE"
        description: "1 if this database is currently paused, else 0"
    - disabled:
        usage: "GAUGE"
        description: "1 if this database is currently paused, else 0"
pgbouncer_show_stats:
  master: true
  query:
    "SELECT _.database,\n_.total_xact_count,\n_.total_query_count,\n_.total_server_assignment_count,\n\
    _.total_received,\n_.total_sent,\n_.total_xact_time,\n_.total_query_time,\n_.total_wait_time,\n\
    _.total_client_parse_count,\n_.total_server_parse_count,\n_.total_bind_count,\n\
    _.avg_xact_count,\n_.avg_query_count,\n_.avg_server_assignment_count,\n_.avg_recv,\n\
    _.avg_sent,\n_.avg_xact_time,\n_.avg_query_time,\n_.avg_wait_time,\n_.avg_client_parse_count,\n\
    _.avg_server_parse_count,\n_.avg_bind_count\nFROM dblink('host=/var/run/postgresql\
    \ port=6432 dbname=pgbouncer user=pgbouncer', 'show stats'::text)\nAS _(database\
    \ text, total_xact_count bigint, total_query_count bigint, total_server_assignment_count\
    \ bigint, total_received bigint, total_sent bigint,total_xact_time bigint, total_query_time\
    \ bigint,\n  total_wait_time bigint, total_client_parse_count bigint, total_server_parse_count\
    \ bigint, total_bind_count bigint, avg_xact_count bigint, avg_query_count bigint,\
    \ avg_server_assignment_count bigint,\n  avg_recv bigint, avg_sent bigint, avg_xact_time\
    \ bigint, avg_query_time bigint, avg_wait_time bigint, avg_client_parse_count\
    \ bigint, avg_server_parse_count bigint, avg_bind_count bigint);\n"
  metrics:
    - database:
        usage: "LABEL"
        description: "Database name"
    - total_xact_count:
        usage: "GAUGE"
        description: "Total number of SQL transactions pooled"
    - total_query_count:
        usage: "GAUGE"
        description: "Total number of SQL queries pooled"
    - total_server_assignment_count:
        usage: "GAUGE"
        description: "Total times a server was assigned to a client"
    - total_received:
        usage: "GAUGE"
        description: "Total volume in bytes of network traffic received"
    - total_sent:
        usage: "GAUGE"
        description: "Total volume in bytes of network traffic sent"
    - total_xact_time:
        usage: "GAUGE"
        description:
          "Total number of microseconds spent by pgbouncer when connected\
          \ to PostgreSQL in a transaction"
    - total_query_time:
        usage: "GAUGE"
        description:
          "Total number of microseconds spent by pgbouncer when actively\
          \ connected to PostgreSQL"
    - total_wait_time:
        usage: "GAUGE"
        description: "Time spent by clients waiting for a server, in microseconds"
    - total_client_parse_count:
        usage: "GAUGE"
        description:
          "Total number of prepared statements created by clients. Only applicable\
          \ in named prepared statement tracking mode, see max_prepared_statements"
    - total_server_parse_count:
        usage: "GAUGE"
        description:
          "Total number of prepared statements created by pgbouncer on a\
          \ server. Only applicable in named prepared statement tracking mode, see max_prepared_statements"
    - total_bind_count:
        usage: "GAUGE"
        description:
          "Total number of prepared statements readied for execution by clients\
          \ and forwarded to PostgreSQL by pgbouncer. Only applicable in named prepared\
          \ statement tracking mode, see max_prepared_statements"
    - avg_xact_count:
        usage: "GAUGE"
        description: "Average transactions per second in last stat period"
    - avg_query_count:
        usage: "GAUGE"
        description: "Average queries per second in last stat period"
    - avg_server_assignment_count:
        usage: "GAUGE"
        description:
          "Average number of times a server as assigned to a client per second\
          \ in the last stat period"
    - avg_recv:
        usage: "GAUGE"
        description: "Average received from clients bytes per second"
    - avg_sent:
        usage: "GAUGE"
        description: "Average sent to clients bytes per second"
    - avg_xact_time:
        usage: "GAUGE"
        description: "Average transaction duration, in microseconds"
    - avg_query_time:
        usage: "GAUGE"
        description: "Average query duration, in microseconds"
    - avg_wait_time:
        usage: "GAUGE"
        description:
          "Time spent by clients waiting for a server, in microseconds average\
          \ per second"
    - avg_client_parse_count:
        usage: "GAUGE"
        description:
          "Average number of prepared statements created by clients. Only\
          \ applicable in named prepared statement tracking mode, see max_prepared_statements."
    - avg_server_parse_count:
        usage: "GAUGE"
        description:
          "Average number of prepared statements created by pgbouncer on\
          \ a server. Only applicable in named prepared statement tracking mode, see\
          \ max_prepared_statements"
    - avg_bind_count:
        usage: "GAUGE"
        description:
          "Average number of prepared statements readied for execution by\
          \ clients and forwarded to PostgreSQL by pgbouncer. Only applicable in named\
          \ prepared statement tracking mode, see max_prepared_statements"
node_filesystem:
  master: true
  query:
    "WITH mounts AS (\n  SELECT columns[1] AS device,\n    columns[2] AS mountpoint\n\
    \    FROM (SELECT regexp_split_to_array(line, E'\\\\s+') AS columns\n        FROM\
    \ mounts() AS line) AS mounts\n  WHERE columns[2] LIKE '/var/%')\nSELECT CASE\
    \ WHEN columns[1] <> '-' THEN columns[1] ELSE NULL END AS device,\n    CASE WHEN\
    \ columns[2] <> '-' THEN columns[2] ELSE NULL END AS mountpoint,\n    CASE WHEN\
    \ columns[3] <> '-' THEN columns[3] ELSE NULL END AS fstype,\n    CASE WHEN columns[4]\
    \ <> '-' THEN columns[4] ELSE NULL END AS size_bytes,\n    CASE WHEN columns[5]\
    \ <> '-' THEN columns[5] ELSE NULL END AS avail_bytes,\n    CASE WHEN columns[6]\
    \ <> '-' THEN columns[6] ELSE NULL END AS files,\n    CASE WHEN columns[7] <>\
    \ '-' THEN columns[7] ELSE NULL END AS files_free,\n    CASE WHEN columns[8] <>\
    \ '-' AND columns[8] <> 'timeout' THEN TRUE ELSE FALSE END AS device_error\n \
    \ FROM (SELECT regexp_split_to_array(line, E'\\\\s+') AS columns\n      FROM (SELECT\
    \ df(mountpoint) AS line FROM mounts) AS df) AS df;\n"
  metrics:
    - device:
        usage: "LABEL"
        description: "Device of the filesystem."
    - mountpoint:
        usage: "LABEL"
        description: "Mount point of the filesystem."
    - fstype:
        usage: "LABEL"
        description: "The type of filesystem."
    - size_bytes:
        usage: "GAUGE"
        description: "Filesystem size in bytes."
    - avail_bytes:
        usage: "GAUGE"
        description: "Filesystem space available to non-root users in bytes."
    - files:
        usage: "GAUGE"
        description: "Filesystem total file nodes."
    - files_free:
        usage: "GAUGE"
        description: "Filesystem total free file nodes."
    - device_error:
        usage: "GAUGE"
        description:
          "Whether an error occurred while getting statistics for the given\
          \ device."
pg_statements:
  query:
    "SELECT * FROM dblink(\n    'host=/var/run/postgresql port=5432 user=' ||\
    \ CURRENT_USER || ' sslmode=disable dbname=postgres',\n    '\n    SELECT\n   \
    \     pg_database.datname,\n        pg_roles.rolname as usename,\n        pg_stat_statements.queryid,\n\
    \        pg_stat_statements.calls as calls_total,\n    '\n    || CASE WHEN (SELECT\
    \ setting FROM pg_settings WHERE name = 'server_version_num')::bigint >= 130000\
    \ THEN\n      '\n        pg_stat_statements.total_exec_time / 1000 AS total_exec_time,\n\
    \        pg_stat_statements.mean_exec_time / 1000 AS mean_exec_time,\n      '\n\
    \      ELSE\n      '\n        pg_stat_statements.total_time / 1000 AS total_exec_time,\n\
    \        pg_stat_statements.mean_time / 1000 AS mean_exec_time,\n      '\n   \
    \   END\n    || '\n        pg_stat_statements.rows as rows_total\n    FROM pg_stat_statements\n\
    \    JOIN pg_roles ON (pg_stat_statements.userid = pg_roles.oid)\n    JOIN pg_database\
    \ ON (pg_stat_statements.dbid = pg_database.oid)\n    ')\n    AS (datname text,\
    \ usename text, queryid bigint, calls_total bigint, total_exec_time double precision,\
    \ mean_exec_time double precision, rows_total bigint)\n    WHERE calls_total >\
    \ 1\n    ORDER BY total_exec_time -mean_exec_time * calls_total desc\n    LIMIT\
    \ 20;\n"
  master: true
  metrics:
    - datname:
        usage: "LABEL"
        description: "Database name"
    - usename:
        usage: "LABEL"
        description: "User name"
    - queryid:
        usage: "LABEL"
        description: "Query ID"
    - calls_total:
        usage: "GAUGE"
        description: "Total calls of the query"
    - total_exec_time:
        usage: "GAUGE"
        description: "Total execute time in milliseconds"
    - mean_exec_time:
        usage: "GAUGE"
        description: "Total mean time in milliseconds"
    - rows_total:
        usage: "GAUGE"
        description: "Total rows returned"
